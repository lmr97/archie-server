import React from 'react';
import { useRef, useState } from 'react'; 
import { EventSource, ErrorEvent } from 'eventsource';
import { RingLoader } from 'react-spinners';
import { Line } from 'progressbar.js';
import { ListRow, type ListInfo } from '../server-types';


/* 
    Since these functions and constants don't depend on component 
    states, they can be defined outside of it. It also saves time
    and computing power, since the functions will not be redefined
    on every render.

    Some are exported for testing purposes.
*/

const validAttributes = [
    "actor",
    "additional-directing",
    "additional-photography",
    "art-direction",
    "assistant-director",
    "avg-rating",
    "camera-operator",
    "casting",
    "cast-list",
    "choreography",
    "cinematography",
    "composer",
    "costume-design",
    "country",
    "director",
    "editor",
    "executive-producer",
    "genre",
    "hairstyling",
    "language",
    "lighting",
    "likes",
    "makeup",
    "mini-theme",
    "original-writer",
    "producer",
    "production-design",
    "set-decoration",
    "songs",
    "sound",
    "special-effects",
    "studio",
    "stunts",
    "theme",
    "title-design",
    "visual-effects",
    "watches",
    "writer"
];

const loadingBarOpts = {
    color: "green",
    easing: "easeOut",
    strokeWidth: 3.0,
    text: {
        value: "",
        className: "loading-bar-text", 
        style: null
    },
};

const loadingBarElement = document.createElement("div");


// error is given in the same format as a ListRow, with the content in the 
// rowData attribute
function streamErrorNotify(errorMessage: string) {
    console.error(`error received: ${errorMessage}`);

    if (errorMessage.includes("422 UNPROCESSABLE CONTENT")) {
        alert("The URL entered doesn't appear to be a valid Letterboxd list. \
            Try checking the link and running it again."
            .replaceAll("  ", "")
        );
    } 
    else if (errorMessage.includes("403 FORBIDDEN")) {
        alert("The server does not accept conversion requests for \
            lists over 10,000 films long. Is there a shorter list we can try?"
            .replaceAll("  ", "")
        );
    }
    else if (errorMessage.includes("502 BAD GATEWAY")) {
        alert("It looks like Letterboxd's servers are down! Try again a little later.");
    }
    else if (errorMessage.includes("500")) {
        alert("There was an issue with the server itself that prevented the completion \
            of your request. My apologies.".replaceAll("  ", "")
        );
    }
    else { 
        alert("There was an issue in processing your request, most \
            likely with the internet connection. My apologies."
            .replaceAll("  ", "")
        ); 
    }
}


// Letterboxd list URLs follow this structure:
//
//    https://letterboxd.com/<username>/list/<listname>/
// 
// Since `lbURLsplit` is an Array, generated by splitting the URL
// string on  `/`, we can get the desired elements out of the URL by 
// indexing into it. This is preferable over forwarding the URL to
// the server, since it elimates the opportunity to inject a malicious
// URL wholesale into the server.
function parseURL(url: string): ListInfo {

    const lbURLsplit: string[] = url.split("/").slice(0,-1); // last element is a null string

    if (!lbURLsplit) {
        throw new Error("Invalid URL (null URL).");
    }
    
    const listName = lbURLsplit.at(-1);
    const author   = lbURLsplit.at(-3);

    // this is probably redundant, but it makes TS happy,
    // and I trust its judgement
    if (!listName || !author || lbURLsplit.at(-2) != "list") {
        throw new Error(`Invalid URL (malformed). URL: ${url}`);
    }

    // TS may be mad, but I've already guarded against these values being undefined
    return {
        listName: listName,
        authorUser: author,
        attrs: new Array()
    }
}


function generateQueryURL(listInfo: ListInfo): string {
    
    var attrsUrlForm = "attrs=none";  // default for empty list
    if (listInfo.attrs.length) {
        attrsUrlForm = listInfo.attrs.map(a => {return "attrs="+a}).join("&");
    }

    const fetchURL = window.location.origin 
        + "/lb-list-conv/conv?"
        + "list_name="   + listInfo.listName   + "&"
        + "author_user=" + listInfo.authorUser + "&"
        + attrsUrlForm;

    testHandle.getGenURL(fetchURL);
    
    return fetchURL;
}


// pretty much ripped straight from: 
// https://www.tutorialspoint.com/how-to-create-and-save-text-file-in-javascript
// This is also essentially the method used in all answers
// to questions on this topic on StackOverflow, so apparently this is
// the industry standard
function downloadList(listName: string, userList: string[]): void {

    testHandle.dlListCalled();

    const csvData = userList.join("\n");
    const csvFile = new Blob([csvData], { type: 'text/csv' });
    const dlLink  = document.createElement("a");

    dlLink.href = URL.createObjectURL(csvFile);     // Add file content in the object URL
    dlLink.download = listName;                     // Add file name
    dlLink.click();                                 // fire click event to <a> tag to save file
    URL.revokeObjectURL(dlLink.href);               // URL no longer needed
}


/* 
    This object exists for testing purposes only,
    so that the testing software can know the timing of
    what was received when (since the spinner/bar display 
    is supposed to be choreographed to these occurences),
    and also verify the correct URL is generated from the
    checked attributes. 
    
    This is done because the relevant functions are inside 
    a React component, as as such are not exportable.
*/
export const testHandle = {
    // functions are preferred here over simple attributes, 
    // because functions can be spied on, but exported attributes
    // cannot be spied on if they change.
    getListCalled: () => {return true},             // to watch when the form event handler is called
    gettingList:   (gettingList: boolean)      => {return gettingList},   // represents gettingList component state
    getGenURL:     (genURL: string)            => {return genURL}, 
    getEvent:      (ev: MessageEvent<ListRow>) => {return ev},  // including the event for debugging
    isComplete:    () => {return true},
    dlListCalled:  () => {return true}
};

export function LetterboxdApp() {

    const filmAttributes        = useRef(new Array<string>());  // I need to keep track of these myself, so I've been told
    const loadingBarElementRef  = useRef(loadingBarElement);
    const errReceivedRef        = useRef(false);                // easy way to communicate between the async message handlers
    const loadingBar            = useRef<any>(null);            // to allow the loading bar object to persist over renders
    
    const [gettingList,  setGettingList]:  [boolean, Function] = useState(false);
    const [percComplete, setPercComplete]: [number,  Function] = useState(0.0);


    function receiveList(listInfo: ListInfo): void {
        
        const queryURL   = generateQueryURL(listInfo);
        const evtSource  = new EventSource(queryURL, {withCredentials: true});
        var userList     = new Array<string>();

        evtSource.onmessage = (event: MessageEvent<ListRow>) => {

            // errors from the server are also delivered as MessageEvents,
            // so ignore those
            if (event.type == "error") return;

            testHandle.getEvent(event);   // for testing purposes
            const msgData: ListRow = event.data;  
            userList.push(msgData.rowData);

            // using function form so that new value is fresh, and not
            // stale from the time of the closure's definition
            setPercComplete((prevPerc: number) => {
                return (prevPerc + (1/msgData.totalRows));
            });
        };

        // This is to catch errors that the SERVER sends BEFORE starting the stream.
        // Errors from the Python app (via the server) are handled by an event listener
        // for messages of type "error" (next function after this one).
        evtSource.onerror = (err: ErrorEvent) => {
            
            setPercComplete(0.0);
            setGettingList(false);

            const errMsg = err.message ? err.message : "Stream failed initiate (error message null).";
            streamErrorNotify(errMsg);

            evtSource.close(); 
        }

        // This catches errors sent by the PYTHON APP via the server, once the stream
        // successfully initiates.
        // 
        // Since the error events from the server are actually messages, not proper 
        // ErrorEvents, we need to use `addEventListener` as well as `onerror`.
        evtSource.addEventListener("error", (errEvent: MessageEvent<string>) => {
    
            // sometimes there is a phantom error event that the server 
            // sends, and I have no idea why, so it doesn't map onto any
            // actual error state in the server. It has no content,
            // howver, so it's easy to distinguish from other, intentionally
            // -programmed error events. This catches those phantom errors.
            if (!errEvent.data) return;   
            errReceivedRef.current = true;
            
            setPercComplete(0.0);
            setGettingList(false);

            streamErrorNotify(errEvent.data);
            evtSource.close(); 
        });

        evtSource.addEventListener("complete", (_) => {

            testHandle.isComplete();   // for testing purposes
            console.debug("Stream complete");
            setGettingList(false);
            setPercComplete(0.0);

            if (!errReceivedRef.current) {
                downloadList(`${listInfo.listName}.csv`, userList);
                evtSource.close();  
            }
        });
    }

    
    function getList(submitEvent: React.FormEvent<HTMLFormElement>) {

        testHandle.getListCalled();

        // Prevent the browser from reloading the page,
        // and from posting the data to the current URL
        // (the default behavior)
        submitEvent.preventDefault();

        const formElement  = submitEvent.currentTarget;
        const listInfoForm = new FormData(formElement);
        const listURLEntry = listInfoForm.get("list-url");

        // no need to raise an error per se, just alert the user and return
        if (!listURLEntry) {
            alert("There isn't a URL given; try again with a URL to a list on Letterboxd.com!");
            return;
        }
        
        const listURL = listURLEntry.toString();

        var listInfo: ListInfo;

        try {
            listInfo = parseURL(listURL);
            // sorting so it's nice for the server. may move this over to server-side.
            listInfo.attrs = filmAttributes.current.sort(); 
            console.debug(listInfo);
        }
        catch(err) {
            alert(
                "There was an issue processing your request, possibly due to a missing or mistyped URL. \
                Try checking that the URL is for a working page on letterboxd.com, and that there aren't \
                typos in it. Otherwise, I'll look into it myself.".replaceAll("  ", "")
            );
            console.error(err)
            return;
        }

        // if nothing goes wrong in the above, THEN we can say we got started
        setGettingList(true);
        errReceivedRef.current = false;     // reset if tripped in the error handler
        testHandle.gettingList(true);       // for testing purposes

        try {receiveList(listInfo);}
        catch(streamingError) {
            streamErrorNotify(streamingError);
        }
    }

    // apparently I have to keep track of states in the form where the input
    // elements are React components (bruh)
    function updateFilmAttributes(checkboxEvent: React.ChangeEvent<HTMLInputElement>): void {
        
        // aliasing for simplicity
        const checkbox: HTMLInputElement = checkboxEvent.currentTarget;

        // remove attribute if has been unchecked
        if (!checkbox.checked) {
            var newAttrList = filmAttributes.current;
            const attrIdx   = newAttrList.indexOf(checkbox.name)

            // if item is found
            if (attrIdx > -1) { 
                newAttrList.splice(attrIdx, 1);     // delete element from list
                filmAttributes.current = newAttrList;
            }
            // otherwise, don't update filmAttributes, since no 
        } 
        // but put it in if it has been checked
        else {
            var newAttrList = filmAttributes.current;
            newAttrList.push(checkboxEvent.currentTarget.name);
            filmAttributes.current = newAttrList;
        }
    }

    function AttributeList() {
        const attrLabels = validAttributes.map(
            (attr: string, idx: number) => {
                return (
                    <label key={idx}>
                        {attr.replaceAll("-", " ")}
                        <input type="checkbox" name={attr} onChange={updateFilmAttributes}/>
                    </label>
                );
            }
        );

        return (
            <div className="checkbox-grid">
                {attrLabels}
            </div>
        );
    }


    // this is a button usually, unless the program is actively getting
    // a Letterboxd list CSV streamed in, then it's either a spinner or
    // loading bar
    function LoadingSpace() {

        if (gettingList && !percComplete) {
            console.debug("sending request...");

            return (
                <RingLoader 
                    data-testid="ring-loader"
                    className="ring-loader"
                    color={"dodgerblue"}
                    loading={gettingList}
                />
            );
        }

        console.debug(`percent complete: ${percComplete}`);

        if (gettingList && percComplete) {
            console.debug("receiving request...");

            if (!loadingBar.current) {
                document.getElementById("button-container")?.appendChild(loadingBarElement);
                loadingBar.current = new Line(loadingBarElement, loadingBarOpts);
            }

            loadingBar.current.animate(percComplete);
            loadingBar.current.setText(
                Math.floor(percComplete * 100).toString() + "%"
            );
            return (
                <div data-testid="loading-bar" className="loading-bar" ref={loadingBarElementRef} />
            );
        }

        if (loadingBar.current) {
            loadingBar.current.destroy();
            loadingBar.current = false;    // .current is still truthy after it's destroyed somehow
        }

        return (
            <button className="lb-list-submit-button" type="submit"
                data-testid="submit-button">
                Get my list!
            </button>
        );
         
    }
    
    return (
        <form onSubmit={getList}>
            <h2>Your list's URL:</h2>
            <div className="lb-url-container">
                <input type="url" className="lb-url" name="list-url" data-testid="url-input"
                    placeholder="url of list goes here..." 
                    pattern="https:\/\/letterboxd.com\/[^\/]+\/list\/[^\/]+\/?"
                    size={80}
                    maxLength={500}
                    required>
                </input>
            </div>
            <h2>The attributes you'd like from it:</h2>
            <AttributeList />
            <div id="button-container" data-testid="button-container">
                <LoadingSpace />
            </div>
        </form>    
    );
}