// I know imports like this are less than ideal, but should 
// be okay on this scale. If there are more packages than this, 
// I will probably switch over to the Browserify bundler.
import '/node_modules/progressbar.js/dist/progressbar.js';

var barOpts = {
    strokeWidth: 2, 
    easing: 'easeOut', 
    color: '#32CD32',
};

var loadingBar = new ProgressBar.Line("#button-container", barOpts);

// "URL validity", for our purposes, means "returns 200 OK".
//
// In order to not duplicate requests, it returns the 
// (estimated) number of films in the Letterboxd list 
// if the URL is valid, `null` if otherwise. 
//
// The async/await silliness is because fetch() runs async, 
// and I need to force it into synchronous exec, because I 
// need the results of its request before proceeding
async function URLisValid (url) {

    // definitely open to there being a better way to do this
    try {
        var estNumFilms = 50;   // standard page size limit

        await fetch(url)
        .then(
            (resp) => {
                if (!resp.ok) {
                    throw new Error(`Invalid URL: ${resp.url}`)
                }
                return resp.text();
            })
        .then(
            (htmlBody) => {
                const fetchedDoc = new DOMParser()
                    .parseFromString(htmlBody, 'text/html');

                const listPages = fetchedDoc
                    .getElementsByClassName("paginate-page");
                
                estNumFilms *= listPages.length;
            });
        
        return estNumFilms;
    }
    catch (e) {
        console.error(`URL caused the following error: ${e}`);
        return null;
    }
}


// displays error message in the HTML, depending on URL validity
// returns boolean whether the error was displayed or not
function displayError() {
    let URLdiv = document.getElementById("lb-url-container");
    let errElement = document.getElementById("err-msg");

    // start by removing the error, if it exists.
    if (errElement) URLdiv.removeChild(errElement);

    // console error reporting handled in URLisValid()

    // add error message to HTML
    let errorChild = document.createElement("p");
    errorChild.id = "err-msg";
    errorChild.style.color = "red";

    URLdiv.appendChild(errorChild);
}


// function from: https://stackoverflow.com/a/33542499
function save(filename, data) {
    const blob = new Blob([data], {type: 'text/csv'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        const elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename; 

        document.body.appendChild(elem);
        elem.click();        
        document.body.removeChild(elem);

        window.URL.revokeObjectURL(elem.href);
    }
}



async function getLBlist() {
    let lbURL      = document.getElementById("lb-url").value;
    let listLength = await URLisValid(lbURL);

    // if there was an error, don't worry about the rest
    if (!listLength) {
        displayError(); 
        return;
    }  

    // replace button with loading bar
    let button = buttonDiv.removeChild(buttonDiv.children[0]);

    // it's easier to estimate the time (in ms) the process will take,
    // using a previously measured time and the number of films 
    // to process, and run the loading bar for that long, than it 
    // is to stream the data in from the server and compare the 
    // completed count to the number of remaining films.
    //
    // Kinda hacky, I know, but this solution is the best I'm aware of
    // given the deliberately challenging design.

    const estTime = listLength * 175;  // average over 300 films, with amortized overhead
    loadingBar.animate(1, {duration: estTime});

    let checkedElements = document
        .querySelectorAll('input[type="checkbox"]:checked');

    // Letterboxd list URLs follow this structure:
    //
    //    https://letterboxd.com/<username>/list/<listname>/
    // 
    // Since `lbURLsplit` is an Array, generated by splitting the URL
    // string on  `/`, we can get the desired elements out of the URL by 
    // indexing into it. This is preferable over forwarding the URL to
    // the server, since it elimates the opportunity to inject a malicious
    // URL wholesale into the server.
    var lbURLsplit  = lbURL.split("/").slice(0,-1); // last element is a null string
    const list_name = lbURLsplit.at(-1);  
    const author    = lbURLsplit.at(-3);

    let attr_list = new Array(checkedElements.length);
    for (let i = 0; i < checkedElements.length; i++) {
        attr_list[i] = checkedElements[i].id;
    }

    // attrs array necessitates a custom URL encoding for request query 
    // (camel-case for Rust API)
    let fetchURL = window.location.href + "/conv?"
        + "list_name="   + list_name + "&"
        + "author_user=" + author    + "&"
        + attr_list
            .map((a) => "attrs="+a)
            .join("&");

    fetch(fetchURL, {credentials: "same-origin"})   // credentials option for testing
        .then((resp) => {
            if (resp.ok) {return resp.text();}
            else {throw new Error(`Request to ${fetchURL} failed with status code ${resp.status}: ${resp.statusText}`)}
        })
        .then((csvText) => {
            loadingBar.animate(1); // complete loading bar
            save(list_name, csvText);
        })
        .catch((e) => {
            console.error(`Error occurred in fetching req: ${e}`);
            alert("There was an issue with the server in processing your request. My apologies.");
        })
        .finally(() => {
            // reset loading bar and replace button for another request
            loadingBar.animate(0, {duration: 100});
            buttonDiv.appendChild(button); 
        }
    );
}

let buttonDiv = document.getElementById("button-container");

document
    .querySelector("button")
    .addEventListener(
        "click", getLBlist
    );